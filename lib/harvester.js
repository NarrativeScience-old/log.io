// Generated by CoffeeScript 1.4.0

/* Log.io Log Harvester

Watches local files and sends new log message to server via TCP.

# Sample configuration:
config =
  nodeName: 'my_server01'
  logStreams:
    web_server: [
      '/var/log/nginx/access.log',
      '/var/log/nginx/error.log'
    ],
  server:
    host: '0.0.0.0',
    port: 28777

# Sends the following TCP messages to the server:
"+node|my_server01|web_server\r\n"
"+bind|node|my_server01\r\n"
"+log|web_server|my_server01|info|this is log messages\r\n"

# Usage:
harvester = new LogHarvester config
harvester.run()
*/


(function() {
  var LogHarvester, LogStream, events, fs, net, winston,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  fs = require('fs');

  net = require('net');

  events = require('events');

  winston = require('winston');

  /*
  LogStream is a group of local files paths.  It watches each file for
  changes, extracts new log messages, and emits 'new_log' events.
  */


  LogStream = (function(_super) {

    __extends(LogStream, _super);

    function LogStream(name, paths, _log) {
      this.name = name;
      this.paths = paths;
      this._log = _log;
    }

    LogStream.prototype.watch = function() {
      var path, _i, _len, _ref;
      this._log.info("Starting log stream: '" + this.name + "'");
      _ref = this.paths;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        path = _ref[_i];
        this._watchFile(path);
      }
      return this;
    };

    LogStream.prototype._watchFile = function(path) {
      var currSize, watcher,
        _this = this;
      if (!fs.existsSync(path)) {
        this._log.error("File doesn't exist: '" + path + "'");
        setTimeout((function() {
          return _this._watchFile(path);
        }), 1000);
        return;
      }
      this._log.info("Watching file: '" + path + "'");
      currSize = fs.statSync(path).size;
      return watcher = fs.watch(path, function(event, filename) {
        if (event === 'rename') {
          watcher.close();
          _this._watchFile(path);
        }
        if (event === 'change') {
          return fs.stat(path, function(err, stat) {
            _this._readNewLogs(path, stat.size, currSize);
            return currSize = stat.size;
          });
        }
      });
    };

    LogStream.prototype._readNewLogs = function(path, curr, prev) {
      var rstream,
        _this = this;
      if (curr < prev) {
        return;
      }
      rstream = fs.createReadStream(path, {
        encoding: 'utf8',
        start: prev,
        end: curr
      });
      return rstream.on('data', function(data) {
        var line, lines, _i, _len, _results;
        lines = data.split("\n");
        _results = [];
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          if (line) {
            _results.push(_this.emit('new_log', line));
          }
        }
        return _results;
      });
    };

    return LogStream;

  })(events.EventEmitter);

  /*
  LogHarvester creates LogStreams and opens a persistent TCP connection to the server.
  
  On startup it announces itself as Node with Stream associations.
  Log messages are sent to the server via string-delimited TCP messages
  */


  LogHarvester = (function() {

    function LogHarvester(config) {
      var paths, s, _ref, _ref1;
      this.nodeName = config.nodeName, this.server = config.server;
      this.delim = (_ref = config.delimiter) != null ? _ref : '\r\n';
      this._log = (_ref1 = config.logging) != null ? _ref1 : winston;
      this.logStreams = (function() {
        var _ref2, _results;
        _ref2 = config.logStreams;
        _results = [];
        for (s in _ref2) {
          paths = _ref2[s];
          _results.push(new LogStream(s, paths, this._log));
        }
        return _results;
      }).call(this);
    }

    LogHarvester.prototype.run = function() {
      var _this = this;
      this._connect();
      return this.logStreams.forEach(function(stream) {
        return stream.watch().on('new_log', function(msg) {
          if (_this._connected) {
            return _this._sendLog(stream, msg);
          }
        });
      });
    };

    LogHarvester.prototype._connect = function() {
      var _this = this;
      this.socket = new net.Socket;
      this.socket.on('error', function(error) {
        _this._connected = false;
        _this._log.error("Unable to connect server, trying again...");
        return setTimeout((function() {
          return _this._connect();
        }), 2000);
      });
      this._log.info("Connecting to server...");
      return this.socket.connect(this.server.port, this.server.host, function() {
        _this._connected = true;
        return _this._announce();
      });
    };

    LogHarvester.prototype._sendLog = function(stream, msg) {
      this._log.debug("Sending log: (" + stream.name + ") " + msg);
      return this._send('+log', stream.name, this.nodeName, 'info', msg);
    };

    LogHarvester.prototype._announce = function() {
      var l, snames;
      snames = ((function() {
        var _i, _len, _ref, _results;
        _ref = this.logStreams;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          l = _ref[_i];
          _results.push(l.name);
        }
        return _results;
      }).call(this)).join(",");
      this._log.info("Announcing: " + this.nodeName + " (" + snames + ")");
      this._send('+node', this.nodeName, snames);
      return this._send('+bind', 'node', this.nodeName);
    };

    LogHarvester.prototype._send = function() {
      var args, mtype;
      mtype = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.socket.write("" + mtype + "|" + (args.join('|')) + this.delim);
    };

    return LogHarvester;

  })();

  exports.LogHarvester = LogHarvester;

}).call(this);
