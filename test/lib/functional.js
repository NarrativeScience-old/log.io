// Generated by CoffeeScript 1.4.0

/* Log.io Functional tests
#
# Stands up all 3 components, verifies that writing to a file
# ends up populating a client collection.
#
# TODO(msmathers): Write more complete test coverage.
*/


(function() {
  var HARVESTER1_CONFIG, HARVESTER2_CONFIG, LOG_SERVER_CONFIG, LogHarvester, LogServer, TEST_FILES, WEB_SERVER_CONFIG, WebClient, WebServer, chai, fpath, fs, logServer, logging, should, sinon_chai, test, webServer, winston, _, _i, _len, _ref;

  fs = require('fs');

  chai = require('chai');

  _ = require('underscore');

  winston = require('winston');

  sinon_chai = require('sinon-chai');

  chai.use(sinon_chai);

  should = chai.should();

  LogHarvester = require('../../lib/harvester.js').LogHarvester;

  _ref = require('../../lib/server.js'), LogServer = _ref.LogServer, WebServer = _ref.WebServer;

  WebClient = require('../../lib/client.js').WebClient;

  logging = new winston.Logger({
    transports: [
      new winston.transports.Console({
        level: 'error'
      })
    ]
  });

  TEST_FILES = ['/tmp/stream1a.log', '/tmp/stream1b.log', '/tmp/stream2a.log', '/tmp/stream2b.log', '/tmp/stream3a.log', '/tmp/stream3b.log', '/tmp/stream4a.log', '/tmp/stream4b.log'];

  HARVESTER1_CONFIG = {
    logging: logging,
    nodeName: 'server01',
    logStreams: {
      stream1: TEST_FILES.slice(0, 2),
      stream2: TEST_FILES.slice(2, 4)
    },
    server: {
      host: '0.0.0.0',
      port: 28771
    }
  };

  HARVESTER2_CONFIG = {
    logging: logging,
    nodeName: 'server02',
    logStreams: {
      stream2: TEST_FILES.slice(4, 6),
      stream3: TEST_FILES.slice(6, 8)
    },
    server: {
      host: '0.0.0.0',
      port: 28771
    }
  };

  LOG_SERVER_CONFIG = {
    logging: logging,
    port: 28771
  };

  WEB_SERVER_CONFIG = {
    logging: logging,
    port: 28772
  };

  for (_i = 0, _len = TEST_FILES.length; _i < _len; _i++) {
    fpath = TEST_FILES[_i];
    fs.writeFile(fpath, '');
  }

  logServer = new LogServer(LOG_SERVER_CONFIG);

  webServer = new WebServer(logServer, WEB_SERVER_CONFIG);

  webServer.run();

  test = function() {
    var webClient;
    describe('LogServer', function() {
      var harvester1, harvester2;
      it('should have no nodes or streams initially', function() {
        _.keys(logServer.logNodes).should.have.length(0);
        return _.keys(logServer.logStreams).should.have.length(0);
      });
      harvester1 = new LogHarvester(HARVESTER1_CONFIG);
      harvester2 = new LogHarvester(HARVESTER2_CONFIG);
      harvester1.run();
      harvester2.run();
      return it('should have registered nodes & streams once connected', function() {
        logServer.logNodes.should.have.keys('server01', 'server02');
        return logServer.logStreams.should.have.keys('stream1', 'stream2', 'stream3');
      });
    });
    webClient = new WebClient({
      host: 'http://0.0.0.0:28772'
    });
    return describe('WebClient', function() {
      return it('waits for server connection...', function(connected) {
        return webClient.socket.on('initialized', function() {
          describe('WebClient state', function() {
            it('should be notified of registered nodes & streams', function() {
              webClient.logNodes.should.have.length(2);
              return webClient.logStreams.should.have.length(3);
            });
            return it('creates a log screen and actives a node/stream pair', function() {
              var node1, screen1, stream1;
              screen1 = webClient.createScreen('Screen 1');
              stream1 = webClient.logStreams.get('stream1');
              node1 = webClient.logNodes.get('server01');
              screen1.addPair(stream1, node1);
              screen1.logMessages.should.have.length(0);
              return describe('log message propagation', function() {
                return it('should populate client backbone collection on file writes', function(done) {
                  var msg1, msg2;
                  msg1 = "log message 1";
                  msg2 = "log message 2";
                  fs.appendFileSync(TEST_FILES[0], "" + msg1 + "\n");
                  fs.appendFileSync(TEST_FILES[2], "" + msg2 + "\n");
                  return webClient.socket.once('new_log', function() {
                    screen1.logMessages.should.have.length(1);
                    screen1.logMessages.at(0).get('message').should.equal(msg1);
                    return done();
                  });
                });
              });
            });
          });
          return connected();
        });
      });
    });
  };

  setTimeout(test, 200);

}).call(this);
